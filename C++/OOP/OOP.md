1. **Абстракция** -  выделение значимой информации и исключение из рассмотрения незначимой.
2. **Инкапсуляция** - свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе.
3. **Полиморфизм** - свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
4. **Наследование** - свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.
<u>Класс</u> - объявляемые типы
<u>Объект</u> - переменная, имеющие данный тип (класс)
<u>Методы</u> - операции, разрешенные над данными типами (классами)
<u>Поля</u> - данные, хранящиеся в классе
```c++
struct A {
  int a;
  double b;
  struct AA {
    char c;
  }
}
// sizeof(A) = 16
```

```c++
struct {
  ...
} a; // объявление анонимной структуры в переменной a
```
*Класс можно объявлять внутри функции*
#### Rule of three
- Оператор присваивания
- Конструктор копирования
- Деструктор
#### Оператор присваивания
Используем copy and swap
Почему T&?
- void - нельзя делать несколько присваиваний в одну строку
- T - аналогично. Несколько присвавиваний работали бы некорректно 
- const T& - а зачем константа??
#### Статические поля и методы
Статические методы работают как функции, но находятся в поле видимости класса
```c++
struct S {
  static int x = 1; // CE
  static const int x = 1; // OK
}

int S::x = 1; // OK
```
#### Перегрузка операторов
- нельзя доопределить свой
- нельзя поменять порядок вычисления и приоритет
- нельзя поменять ассоциативность
```c++
struct Complex {
  long long re;
  double im;
  
  Complex operator""_c(unsigned long long) { // литеральный суффикс;
  }

  // partial_ordering, weak_ordering, strong_ordering
  std::strong_ordering operator<=>(const Complex& other) const = default;
   // сравнения оперделяются лексикографически
  friend std::ostream& operator<<(std::ostream&, const Complex&);
}

Complex operator+(const Complex& a, const Complex& b) const {
  Complex copy = a;
  copy += b;
  return copy;
}

std::ostream& operator<<(std::ostream& out, const Complex& a) {
  out << a.re << " " << a.im;
}
```
- == и != не доопределяются spaceship'ом при нетривиальной реализации
#### Enum
- enum - равносильно внесению константы в глобальную область видимости, enum class - нет
- enum разрешает неявные конверсии, enum class - запрещает
```c++
enum E {
  White, // 0
  Gray, // 1
  Black // 2
}

enum class E {
  White = 10,
  Gray, // 11
	  Black // 12
}
```

```c++
struct {

} a; // объявнение анонимной структуры в переменной a
```

## friend
```c++
struct C {
  friend int main(); // можно определить на месте
  friend class CC;
}
```